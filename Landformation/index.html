<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Landforms Table Drag & Drop (Compact Rows)</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background: #fff;
    }
    h1 {
      margin-bottom: 10px;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      max-width: 900px;
    }
    th, td {
      border: 1px solid #d97b00; /* thinner border */
      padding: 4px;              /* reduced padding */
      text-align: center;
      font-size: 0.9em;          /* optional smaller font */
    }
    th {
      background-color: #f4831b; 
      color: #fff;
    }
    /* Light shading for table rows */
    tr:nth-child(even) td {
      background-color: #ffece0;
    }

    /* Drop zones in table cells */
    .dropzone {
      min-height: 24px; /* smaller minimum height */
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
    }
    /* White w/ orange border (Dominant Process cells) */
    .process-drop {
      border: 1px dashed #d97b00; 
    }
    /* Orange w/ white border (Agent of Formation cells) */
    .agent-drop {
      border: 1px dashed #fff; 
    }

    /* Banks of draggable items */
    #banksContainer {
      display: flex;
      flex-wrap: wrap;
      margin-top: 20px;
    }
    .bank {
      flex: 1;
      min-width: 300px;
      margin-right: 20px;
    }
    .bank h2 {
      background-color: #f4831b; 
      color: #fff;
      padding: 6px 10px;
      border-radius: 4px;
      margin-top: 0;
      font-size: 1em; /* smaller heading if you like */
    }

    /* Draggables */
    .draggable {
      margin: 4px 0;         /* smaller margin */
      padding: 4px 8px;      /* smaller padding */
      display: inline-block;
      cursor: move;
      text-align: center;
      border-radius: 6px;
      font-size: 0.9em;
    }
    .process-item {
      background-color: #fff;
      border: 2px solid #d97b00;
    }
    .agent-item {
      background-color: #f4831b;
      border: 2px solid #fff;
      color: #fff;
    }
    .draggable:hover {
      opacity: 0.85;
    }

    /* Highlight dropzone on dragover */
    .highlight {
      outline: 2px dashed #777;
    }

    /* Correct / incorrect feedback */
    .correct {
      background-color: #c3f7c3 !important; /* light green */
      color: #000 !important;
    }
    .incorrect {
      background-color: #f9c3c3 !important; /* light red */
      color: #000 !important;
    }

    /* Buttons */
    .btn {
      margin-top: 20px;
      padding: 8px 16px;
      font-size: 14px;
      border-radius: 20px;
      border: none;
      cursor: pointer;
    }
    #checkButton {
      background-color: #007bff;
      color: #fff;
    }
    #retryButton {
      background-color: #ccc;
      color: #333;
      margin-left: 10px;
    }
    #copyButton {
      background-color: #28a745;
      color: #fff;
      margin-left: 10px;
      display: none; /* hidden until all correct */
    }
  </style>
</head>
<body>

<h1>Landforms: Dominant Process &amp; Agent of Formation</h1>
<p><em>Drag from the banks below into each cell. Then click “Check.” If all correct, a “Copy” button appears to let you copy the table.</em></p>

<!-- The main table -->
<table id="landformsTable">
  <thead>
    <tr>
      <th>LANDFORM</th>
      <th>DOMINANT PROCESS</th>
      <th>AGENT OF FORMATION</th>
    </tr>
  </thead>
  <tbody>
    <!-- We'll generate 12 rows. Each row has:
         1) Landform name
         2) .dropzone.process-drop (data-drop="rowIndex-P")
         3) .dropzone.agent-drop   (data-drop="rowIndex-A")
    -->
  </tbody>
</table>

<!-- Buttons for checking / retry / copy -->
<button id="checkButton" class="btn">Check</button>
<button id="retryButton" class="btn">Restart</button>
<button id="copyButton" class="btn">Copy</button>

<!-- Draggable item banks -->
<div id="banksContainer">
  <div class="bank" id="processBank">
    <h2>Dominant Processes</h2>
  </div>
  <div class="bank" id="agentBank">
    <h2>Agents of Formation</h2>
  </div>
</div>

<script>
// Rows data
const rowsData = [
  { landform: "Butte",         process: "Erosional",    agent: "Aeolian"   },
  { landform: "Volcano",       process: "Tectonic",     agent: "Volcanic"  },
  { landform: "Flood Plain",   process: "Depositional", agent: "Fluvial"   },
  { landform: "Mesa",          process: "Erosional",    agent: "Aeolian"   },
  { landform: "Harbour",       process: "Erosional",    agent: "Coastal"   },
  { landform: "Delta",         process: "Depositional", agent: "Fluvial"   },
  { landform: "River",         process: "Erosional",    agent: "Fluvial"   },
  { landform: "Glacier",       process: "Erosional",    agent: "Glacial"   },
  { landform: "Mountain",      process: "Tectonic",     agent: "Orogenic"  },
  { landform: "Canyon",        process: "Erosional",    agent: "Fluvial"   },
  { landform: "Island Arch.",  process: "Tectonic",     agent: "Volcanic"  },
  { landform: "Beach",         process: "Depositional", agent: "Coastal"   }
];

// Build the table rows
const tableBody = document.querySelector("#landformsTable tbody");
rowsData.forEach((rowObj, idx) => {
  const tr = document.createElement("tr");

  // 1) Landform cell
  const tdLand = document.createElement("td");
  tdLand.textContent = rowObj.landform;
  tr.appendChild(tdLand);

  // 2) Process cell
  const tdProc = document.createElement("td");
  tdProc.classList.add("dropzone", "process-drop");
  tdProc.dataset.drop = `${idx}-P`;
  tr.appendChild(tdProc);

  // 3) Agent cell
  const tdAgent = document.createElement("td");
  tdAgent.classList.add("dropzone", "agent-drop");
  tdAgent.dataset.drop = `${idx}-A`;
  tr.appendChild(tdAgent);

  tableBody.appendChild(tr);
});

// Create “Dominant Process” items and “Agent of Formation” items in random order
const processBank = document.getElementById("processBank");
const agentBank   = document.getElementById("agentBank");

let processItems = [];
let agentItems   = [];

rowsData.forEach((row, idx) => {
  // process item
  const divP = document.createElement("div");
  divP.classList.add("draggable", "process-item");
  divP.setAttribute("draggable", "true");  // <-- Make sure it's actually draggable
  divP.dataset.correct = `${idx}-P`;
  divP.textContent = row.process;
  processItems.push(divP);

  // agent item
  const divA = document.createElement("div");
  divA.classList.add("draggable", "agent-item");
  divA.setAttribute("draggable", "true");  // <-- Also draggable
  divA.dataset.correct = `${idx}-A`;
  divA.textContent = row.agent;
  agentItems.push(divA);
});

shuffle(processItems);
shuffle(agentItems);
processItems.forEach(item => processBank.appendChild(item));
agentItems.forEach(item => agentBank.appendChild(item));

// Enable drag events
document.querySelectorAll(".draggable").forEach(d => {
  d.addEventListener("dragstart", onDragStart);
});

// Make dropzones accept drops
document.querySelectorAll(".dropzone").forEach(zone => {
  zone.addEventListener("dragover", onDragOver);
  zone.addEventListener("dragleave", onDragLeave);
  zone.addEventListener("drop", onDrop);
});
// Also the banks themselves
[processBank, agentBank].forEach(bank => {
  bank.addEventListener("dragover", onDragOver);
  bank.addEventListener("dragleave", onDragLeave);
  bank.addEventListener("drop", onDrop);
});

// Buttons
const checkBtn = document.getElementById("checkButton");
checkBtn.addEventListener("click", onCheck);

const retryBtn = document.getElementById("retryButton");
retryBtn.addEventListener("click", onRetry);

const copyBtn = document.getElementById("copyButton");
copyBtn.addEventListener("click", copyTableToClipboard);

/* --- Drag & Drop Handlers --- */
function onDragStart(ev) {
  if (!ev.target.id) {
    ev.target.id = "drag-" + Math.random().toString(16).slice(2);
  }
  ev.dataTransfer.setData("text/plain", ev.target.id);
  // Optional: ev.dataTransfer.effectAllowed = "move";
}

function onDragOver(ev) {
  ev.preventDefault();
  ev.currentTarget.classList.add("highlight");
}

function onDragLeave(ev) {
  ev.currentTarget.classList.remove("highlight");
}

function onDrop(ev) {
  ev.preventDefault();
  ev.currentTarget.classList.remove("highlight");

  const draggedId = ev.dataTransfer.getData("text/plain");
  const draggedEl = document.getElementById(draggedId);
  if (!draggedEl) return;

  // If it's already here, do nothing
  if (ev.currentTarget.contains(draggedEl)) return;

  ev.currentTarget.appendChild(draggedEl);
}

/* --- Checking Logic --- */
function onCheck() {
  // Lock draggables
  const allDrags = document.querySelectorAll(".draggable");
  allDrags.forEach(d => d.setAttribute("draggable", "false"));

  // Clear old correctness
  allDrags.forEach(d => d.classList.remove("correct", "incorrect"));

  let allCorrect = true;

  // For each dropzone
  document.querySelectorAll(".dropzone").forEach(zone => {
    const occupant = zone.querySelector(".draggable");
    if (!occupant) {
      allCorrect = false;
      return;
    }
    if (occupant.dataset.correct === zone.dataset.drop) {
      occupant.classList.add("correct");
    } else {
      occupant.classList.add("incorrect");
      allCorrect = false;
    }
  });

  // If all correct, show copy button
  if (allCorrect) {
    copyBtn.style.display = "inline-block";
  } else {
    copyBtn.style.display = "none";
  }
}

/* --- Restart Logic --- */
function onRetry() {
  const allDrags = document.querySelectorAll(".draggable");
  allDrags.forEach(d => {
    d.classList.remove("correct", "incorrect");
    d.setAttribute("draggable", "true");
    if (d.classList.contains("process-item")) {
      processBank.appendChild(d);
    } else {
      agentBank.appendChild(d);
    }
  });
  copyBtn.style.display = "none";
}

/* --- Copy Completed Table to Clipboard --- */
async function copyTableToClipboard() {
  let text = "LANDFORM\tDOMINANT PROCESS\tAGENT OF FORMATION\n";
  document.querySelectorAll("#landformsTable tbody tr").forEach((tr, idx) => {
    const landform = rowsData[idx].landform;
    const tdProcess = tr.children[1];
    const occupantP = tdProcess.querySelector(".draggable")?.textContent || "";
    const tdAgent = tr.children[2];
    const occupantA = tdAgent.querySelector(".draggable")?.textContent || "";
    text += `${landform}\t${occupantP}\t${occupantA}\n`;
  });

  try {
    await navigator.clipboard.writeText(text);
    alert("Table copied to clipboard! You can now paste it in your notes.");
  } catch (e) {
    console.error("Copy failed: ", e);
    alert("Copy to clipboard failed.");
  }
}

/* --- Utility: Shuffle (Fisher-Yates) --- */
function shuffle(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}
</script>

</body>
</html>
